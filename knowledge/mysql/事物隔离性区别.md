@[TOC]mysql事物隔离性区别

##　1.四类隔离级别定义

MySQL定义了4类隔离级别，包括一些具体规则，
用来限定事物内外的哪些改变时可见的，哪些改变时不可见的，
低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。

### 1.1Read Uncommitted(读取未提交的内容)

事务A/事务B
在该隔离级别，所有事物都可以看到其他未提交事务的执行结果，
本隔离级别很少用于实际应用，因为他的性能页不比其他级别好多少，
读取未提交的数据，也被称之为脏读（Dirty Read）。

### 1.2 Read Committed(读取提交内容)
这是大多数数据库系统的默认隔离级别（但不是mysql默认的），
他满足了隔离的简单定义：一个事物在提交之前对其他事物是不可见的，
这种隔离级别也支持所谓的不可重复读取（Nonerepeatable Read）,
因为同一事务的其他实例在该实例处理其他期间可能会有新的commit，
所以同一select可能返回不同结果。

### 1.3 Repeatable Read(可复读)
这是mysql默认的隔离级别，
他确保同一事务的多个实例在并发读取数据时，会看到同样的数据行，
不过理论上，这会导致另一个棘手的问题，幻读（Phantom Read），
简单的说，幻读指当用户读取某一范围的数据行时，
另一个事物又在该范围内插入了新行，
当用户再读取该范围内的数据时，会发现有新的"幻影"行，
Innodb和Falcon存储引擎通过多版本并发控制（MVCC）机制解决了该问题。


###　1.4 Serializerable(可串行化)
这是最高的隔离级别，他通过强制事物排序，
使之不可能相互冲突，从而解决了幻读问题，
简言之，它是在每个读的数据行上加共享锁，
在这个级别，可能导致大量的超时现象和锁竞争。

## 2.特性

### 2.1 脏读
某个事务已更新一份数据，另一个事务在此时读取了同一份数据，
由于某些原因，前一个事务RollBack了操作，
则后面的事物所读去的数据就是不正确的。

### 2.2 幻读
在一个事务的两次查询中数据不一致，
例如有一个事务查询了几列数据，
而另一个事务却在此时插入了新的数据，
先前的事务在接下来的查询中，
就会发现有几列数据是他先前所没有的。

### 2.4 不可重复读
在一个事物的两次查询中数据不一致，
这可能是两次查询过程中间插入了一个事物更新的原有的数据。

### 2.5 隔离级别区别

|隔离级别|脏读|不可重复读|幻读|
|---|---|---|---|
|读取未提交内容|会|会|会|
|读取已提交内容|不会|会|会|
|可重复读|不会|不会|会|
|可串行化|不会|不会|不会|

————————————————

版权声明：本文为CSDN博主「FatPuffer」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_42517220/article/details/88779932