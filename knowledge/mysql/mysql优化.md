@[TOC](mysql优化)

## 1.编程代码优化

### 1.1 插入优化

1.批量插入时，使用一次性插入代替循环多次插入

2.插入字段尽量少，尽量用默认值

### 1.2删除优化

1.批量删除，使用一次性删除代替循环多次删除

### 1.3修改优化

1.批量修改，使用一次性修改代替循环多次修改

2.只对需要修改的字段进行修改

### 1.4查询优化

1.只查询需要的字段，不需要的字段不要查询出来。

2. 对索引失效进行优化。

索引失效的情况及优化有：

|关键字|失效描述|优化方案|
|------|------|------|
|like|like 以%开头，索引无效；<br>当like前缀没有%，后缀有%时，索引有效。| 使用后缀%代替查询；<br>或者使用全文索引代替。 |
|or|or语句前后没有同时使用索引。| 对or语句前后的字段进行索引添加 |
| |组合索引，不是使用第一列索引，索引失效。| 对组合索引字段排序进行修改;<br>或者拆分索引。 |
| |数据类型出现隐式转化| 如varchar不加单引号的话可能会自动转换为int型，使索引无效，产生全表扫描。 |
| IS NULL|在索引列上使用 IS NULL 或 IS NOT NULL操作。| 索引是不索引空值的，所以这样的操作不能使用索引，可以用其他的办法处理，<br>例如：数字类型，判断大于0，字符串类型设置一个默认值，判断是否等于默认值即可。 |
| not，<>，!= |在索引字段上使用not，<>，!=。不等于操作符是永远不会用到索引的，因此对它的处理只会产生全表扫描。|  优化方法： key<>0 改为 key>0 or key<0 |
| |对索引字段进行计算操作、字段上使用函数。| 拆分成逻辑运算，再对运算结果进行条件查询 |
| |当全表扫描速度比索引速度快时，mysql会使用全表扫描，此时索引失效。| 如果是查询返回记录过大导致全表扫描速度比索引速度快,使用分页进行查询 |

## 2.数据库优化

### 2.1 合理的配置数据库参数

MYSQL数据库的参数配置一般在my.ini，
配置文件中修改/添加（部分参数也可以用set global 参数名=值 做临时调整，重启后失效），
配置完后需要重启数据库才生效。

|参数|描述|配置优化|
|------|------|------|
|max_connections = 2000  |最大连接数，当数据库面对高并发时，这个值需要调节为一个合理的值，才满足业务的并发要求，避免数据库拒绝连接。| 根据在线人数情况进行设置 |
|max_user_connections=1000  |允许单个用户的连接数最大值，即并发值|  max_user_connections 设置为正常情况下单用户最大连接数的3-5倍 |
|innodb_buffer_pool_size = Gb/MB  |缓冲池大小，包含数据缓存、索引缓存、缓冲数据、内部结构|当主机做为mysql数据库服务器时，一般配置为整机内存的60%~80%|
|innodb_buffer_pool_instances=N  |内存缓冲池实例数，将innodb_buffer_pool_size配置的内存分割成N份，此参数当配置内存大小于1G时才生效| N<= 服务器CPU的个数。|
|innodb_log_buffer_size =32M |日志缓冲区大小|  一般不用设置太大，能存下1秒钟操作的数据日志就行了，mysql默认1秒轮询写一次日志到磁盘。 |
|innodb_flush_log_at_trx_commit  ={0/1/2} |0：log buffer将每秒一次地写入log file中，并且log file的flush(刷到磁盘)操作同时进行。该模式下在事务提交的时候，不会主动触发写入磁盘的操作。<br>1：每次事务提交时MySQL都会把log buffer的数据写入log file，并且flush(刷到磁盘)中去，该模式为系统默认。<br>2：每次事务提交时MySQL都会把log buffer的数据写入log file，但是flush(刷到磁盘)操作并不会同时进行。该模式下，MySQL会每秒执行一次 flush(刷到磁盘)操作。|  一般的实时业务交易配置为2 |
|innodb_read_io_threads = 16 | 数据库读操作时的线程数，用于并发。|  |
|innodb_write_io_threads  = 16 | 数据库写操作时的线程数，用于并发。|  |
|innodb_file_per_table= 1  | 每一个表是否使用独立的数据表空间，默认为OFF（使用共享表空间）| 一般建议配置为1 |
|innodb_stats_on_metadata={ OFF/on}   | 是否动态收集统计信息| 开启时会影响数据库的性能(一般关闭，找个时间手动刷新，或定时刷新）如果为关闭时，需要配置数据库调度任务，定时刷新数据库的统计信息。 |
|innodb_spin_wait_delay=10  | 控制CPU的轮询时间间隔，默认是6| 配置过低时，任务调度比较频繁，会消耗CPU资源。 |
|innodb_lock_wait_timeout=30   | 控制锁的超时时间，默认为50| 这个值要注意，如果有特殊业务确实要耗时较长时，不能配置太短。 |


### 2.2 选择合适数据库中间件

#### 2.2.1什么是中间件？

传统的架构模式就是 应用连接数据库直接对数据进行访问，这种架构特点就是简单方便。

但是随着目前数据量不断的增大我们就遇到了问题:

单个表数据量太大、
单个库数据量太大、
单台数据量服务器压力很大、
读写速度遇到瓶颈

当面临以上问题时，我们会想到的第一种解决方式就是 向上扩展(scale up) 简单来说就是不断增加硬件性能。
这种方式只能暂时解决问题，当业务量不断增长时还是解决不了问题。
特别是淘宝，facebook，youtube这种业务成线性，甚至指数级上升的情况

此时我们不得不依赖于第二种方式： 水平扩展 。 
直接增加机器，把数据库放到不同服务器上，
在应用到数据库之间加一个proxy进行路由，这样就可以解决上面的问题了。

#### 2.2.2.各类中间件比较

Cobar:

阿里巴巴B2B开发的关系型分布式系统，管理将近3000个MySQL实例。
在阿里经受住了考验，后面由于作者的走开的原因cobar没有人维护 了，阿里也开发了tddl替代cobar。

MyCAT:

社区爱好者在阿里cobar基础上进行二次开发，解决了cobar当时存 在的一些问题，并且加入了许多新的功能在其中。
目前MyCAT社区活 跃度很高，目前已经有一些公司在使用MyCAT。总体来说支持度比 较高，也会一直维护下去，

OneProxy:

数据库界大牛，前支付宝数据库团队领导楼总开发，基于mysql官方 的proxy思想利用c进行开发的，
OneProxy是一款商业收费的中间件， 楼总舍去了一些功能点，
专注在性能和稳定性上。有朋友测试过说在 高并发下很稳定。


Vitess:

这个中间件是Youtube生产在使用的，但是架构很复杂。 
与以往中间件不同，使用Vitess应用改动比较大要 使用他提供语言的API接口，
我们可以借鉴他其中的一些设计思想。

Kingshard:

Kingshard是前360Atlas中间件开发团队的陈菲利用业务时间 
用go语言开发的，目前参与开发的人员有3个左右， 目前来看还不是成熟可以使用的产品，需要在不断完善。

Atlas:

360团队基于mysql proxy 把lua用C改写。原有版本是支持分表， 目前已经放出了分库分表版本。
在网上看到一些朋友经常说在高并 发下会经常挂掉，如果大家要使用需要提前做好测试。

MaxScale与MySQL Route:

这两个中间件都算是官方的吧，MaxScale是mariadb (MySQL原作者维护的一个版本)研发的，
目前版本不支持分库分表。

MySQL Route是现在MySQL 官方Oracle公司发布出来的一个中间件。

### 2.3 根据业务进行分库分表



### 2.4 根据业务选择表引擎，字段类型，字段长度

### 2.5 合理创建索引


————————————————

数据库中间件参考
版权声明：本文为CSDN博主「九品下」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_42517220/article/details/88779932