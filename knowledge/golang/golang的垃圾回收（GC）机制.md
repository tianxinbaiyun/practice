@[TOC](golang的垃圾回收（GC）机制)

## 介绍

golang的垃圾回收采用的是 标记-清理（Mark-and-Sweep） 算法

就是先标记出需要回收的内存对象快，然后在清理掉；

在这里不介绍标记和清理的具体策略（可以参考https://lengzzz.com/note/gc-in-golang），只介绍 GC过程是怎么调度的以及stw相关

这个算法，会导致 stw (stop the world)的问题，中断用户逻辑

## 触发GC机制

1. 在申请内存的时候，检查当前当前已分配的内存是否大于上次GC后的内存的2倍，若是则触发（主GC线程为当前M）

2. 监控线程发现上次GC的时间已经超过两分钟了，触发；将一个G任务放到全局G队列中去。（主GC线程为执行这个G任务的M）

 

## 每当触发的时候，在主GC线程中就会走如下的GC流程：

1.    stop the world，等待所有的M休眠；此时所有的业务逻辑代码都停止

2.    标记：分配gc标记任务，唤醒 gcproc个 M（就是第一步休眠的那些），分别做这个，直到所有的M都做完，才结束；并且所有M再次进入休眠

3.    清理：有一个单独的goroutine去清理已经标记的内存对象快

4.    start the world，设置gcwaiting=0，唤醒所有的M（不会超过P个数）

 

对于上面的三个步骤，分别解释：

### stop the world：

1.    设置gcwaiting=1，这个在每一个G任务之前会检查一次这个状态，如是，则会将当前M休眠；

2.    如果这个M里面正在运行一个长时间的G任务，咋办呢，难道会等待这个G任务自己切换吗？这样的话可要等10ms啊，不能等！坚决不能等！
所以会主动发出抢占标记（类似于上一篇），让当前G任务中断，再运行下一个G任务的时候，就会走到第1步

3.    一直等待所有的M进入休眠，此时所有的业务逻辑代码都停止

### 标记：

1.     根据gcproc的个数，分配成gcproc任务段；唤醒gcproc-1个M来执行（当前M也算一个）

2.    对于一个M，唤醒前设置它的helpgc标记，唤醒之后这个M会立马判断这个标记，如是，则开始做分配给自己的标记任务，如果先做完了，就会从别的M里面找一些来做

3.    等每一个M都做完，会再次进入休眠

### 清理：

1.    通过设置参数，可以以一个单独goroutine  运行，这个功能是在1.3版本之后增加的，这样的话就直接到下一步了，清理过程不是stw的

2.    也可以串行的在主GC线程执行；这样的话则清理过程也是stw的，

### start the world：

1.    设置gcwaiting=0

2.    唤醒P个M来继续做G任务（此时没有helpgc标记），业务逻辑代码开始

 

### 综上：

是基于1.4版本的，GC过程在标记过程是（STW）的

在1.5版本里面对GC做了很大的优化；采用三色标记，将标记过程细化成三段，只有前后的两段是stw的；极大地缩短了gc的stw时间

![alt](https://img-blog.csdn.net/20170222150953367?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlhbmd6aGl5YW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

————————————————


版权声明：本文为CSDN博主「正版两只羊」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/liangzhiyang/article/details/52670021